As to avoid deadlock between concurrently moving pieces/dissallow pieces from overtaking one another, several factors must be discussed. The board that represents piece placement is a 2d array of ReentrantLocks. When initialized each thread locks its starting position on the board. Whenever a move is randomly generated from there on out, it tests if the next lock is available. If not, then it may step to that position. If it is locked, then it doesnt make that move. This is a generalization, however the moving implementation is different for Queens and Knights. A Knight only has to look at one space, and if the space isnt locked then it moves there. A Queen knows that it wants to move a set number of spots, but it cant jump over locked spaces. So, it incrementally attempts to lock each subsequent space until the randomly generate move is satisfied. If there is a piece in the way of the originally generate move, then the Queen simply stops wherever it got to up until that point.

In order to have the number of moves printed at an instantaneous point in the time without misrepresenting the number moves actually made at that instant, a barrier lock is implemented. A non-piece thread, namely PrintCount, sets its intention to print once every second by setting a boolean variable to true. This thread then waits on a lock (printReadyLock) in order to be notified of when it may continue executing. Once each ChessPiece eventually sees PrintCount's intention to print, it waits on another lock (printLock) which waits to be notified that they may continue executing. When the last ChessPiece thread is in the process of obtaining and waiting on printLock, it notifies PrintCount that all threads have reached that point (aka barrier) and that it may move on to print. After the printing job is done, PrintCount notifies all of the ChessPieces that it is done, and they all continue with their executions. This assures that no piece is in the middle of a move while printing.